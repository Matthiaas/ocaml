
#         Characters 92-115:
    type _ t = T : 'a -> 'a s t
        ^^^^^^^^^^^^^^^^^^^^^^^
Error: In this definition, a type variable cannot be deduced
       from the type parameters. It was expected to be unrestricted,
       but it is injective invariant.
# Characters 11-12:
  module M = F (struct type 'a s = int end) ;;
             ^
Error: Unbound module F
# Characters 4-7:
  let M.T x = M.T 3 in x = true;;
      ^^^
Error: Unbound module M
#           Characters 48-51:
  module F (S : sig type #'a s end) = struct
                ^^^
Syntax error: 'end' expected, the highlighted 'sig' might be unmatched
# * * * * *             Characters 296-374:
  ........['a] c x =
      object constraint 'a = 'b T.t val x' : 'b = x method x = x' end
Error: In this definition, a type variable cannot be deduced
       from the type parameters. It was expected to be unrestricted,
       but it is injective invariant.
#     type (_, _) eq = Eq : ('a, 'a) eq
# val eq : 'a = <poly>
#   val eq : ('a Queue.t, 'b Queue.t) eq = Eq
# Characters 4-33:
  type _ t = T : 'a -> 'a Queue.t t;; (* fail *)
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: In this definition, a type variable cannot be deduced
       from the type parameters. It was expected to be unrestricted,
       but it is injective invariant.
# * * * *             Characters 223-246:
    type _ t = T : 'a -> 'a s t
        ^^^^^^^^^^^^^^^^^^^^^^^
Error: In this definition, a type variable cannot be deduced
       from the type parameters. It was expected to be unrestricted,
       but it is injective invariant.
#   Characters 59-60:
  module rec M : (S with type 'a s = unit) = M;;
                  ^
Error: Unbound module type S
# * *   
